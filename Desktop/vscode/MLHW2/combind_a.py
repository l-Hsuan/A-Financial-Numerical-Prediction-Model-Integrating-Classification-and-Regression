# -*- coding: utf-8 -*-
"""combind_a.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qdPnxS7vDfFk3apMARlA5HovjuOwftDw
"""

import os
import numpy as np
import pandas as pd

# Folder paths
value_folder = "C:\\Users\\user\\Desktop\\vscode\\MLHW2\\modeltxt"  # Replace with the folder path containing value files
classification_folder = "C:\\Users\\user\\Desktop\\vscode\\MLHW2\\classmodeltxt"  # Replace with the folder path containing classification result files

# Evaluation data paths
eval_y = "C:\\Users\\user\\Desktop\\vscode\\MLHW2\\y.csv"
eval_w = "C:\\Users\\user\\Desktop\\vscode\\MLHW2\\y_w.csv"

# Utility function to read files
def read_file(filepath):
    with open(filepath, "r") as file:
        data = np.array([float(line.strip()) for line in file])  # Read numbers and convert to numpy array
    return data

# Read files in the folder
def load_files(folder_path):
    files_data = {}
    for file_name in os.listdir(folder_path):
        if file_name.endswith("_predictions.txt"):  # Filter files
            model_name = "_".join(file_name.split("_")[:2])  # Extract model name (e.g., xgb_0, lgb_4)
            files_data[model_name] = read_file(os.path.join(folder_path, file_name))
    return files_data

# Load value files and classification files
value_data = load_files(value_folder)
classification_data = load_files(classification_folder)

for key, array in classification_data.items():
    classification_data[key] = np.where(array == 0, -1, array)

# Processing function
def adjust_values(value_data, classification_data):
    adjusted_dict = {}
    for key, original_values in value_data.items():
        result = key.split("_")[0]+'_0'
        classification_data_arr = classification_data[f'{result}']
        # Compare signs and make modifications
        adjusted_values = np.where(
            np.sign(original_values) == classification_data_arr,  # Signs match
            original_values,  # Keep original values
            0  # Otherwise fill with 0
        )
        adjusted_dict[key] = adjusted_values

    return adjusted_dict

# Perform adjustments
adjusted_dict = adjust_values(value_data, classification_data)

df = pd.DataFrame.from_dict(adjusted_dict)
df["non_zero_mean"] = df.replace(0, pd.NA).mean(axis=1).fillna(0)

"""# Performance Evaluation"""

def r2(y_true, y_pred, sample_weight):
    r2 = 1 - np.average((y_pred - y_true) ** 2, weights=sample_weight) / (np.average((y_true) ** 2, weights=sample_weight) + 1e-38)
    return r2

data1 = pd.read_csv(eval_y)
data2 = pd.read_csv(eval_w)

r2 = 1 - np.average((df["non_zero_mean"].values - data1['responder_6'].values) ** 2, weights=data2['weight'].values) / (np.average((data1['responder_6'].values) ** 2, weights=data2['weight'].values) + 1e-38)

r2
